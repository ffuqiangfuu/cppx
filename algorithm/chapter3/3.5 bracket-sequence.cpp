#include <iostream>
#include <cstring>
#include <string>
#include <vector>

using namespace std;

// 模数，防止方案数溢出
const int mod = 998244353;
// N 的最大范围是 5000，数组开稍微大一点
const int MAXN = 5005;

// dp[i][j]: 表示处理完前 i 个字符后，左括号比右括号多 j 个（当前积分为 j）的方案数
int dp[MAXN][MAXN];

// reachable[i][j]: 表示处理完前 i 个字符后，当前积分为 j，是否存在一种后续填法能让最终积分为 0（合法）
// true 表示“此路可通”，false 表示“此路不通”
bool reachable[MAXN][MAXN];

string s; // 输入的字符串
int n;    // 字符串长度

// ---------------------------------------------------------
// 模块1：预处理可行性 (legalSeq)
// 作用：倒着推导。如果我们处于状态 (i, j)，后面能不能走通？
// ---------------------------------------------------------
void legalSeq() {
    // 初始化全为 false
    memset(reachable, false, sizeof(reachable));
    
    // 终点状态必须是 (n, 0)，即处理完所有字符，积分必须回归 0
    reachable[n][0] = true; 
    
    // 倒序遍历：从最后一个字符往前推
    for (int i = n; i > 0; i--) { 
        for (int j = 0; j <= i; j++) {
            // 如果 s[i] 是 '(' 或者是 '*' (可以变成 '(' )
            // 那么它是从状态 (i-1, j-1) 变成状态 (i, j) 的
            // 所以，如果状态 (i, j) 是通的，那么前一步状态 (i-1, j-1) 也是通的
            if (s[i] == '(' || s[i] == '*') {
                if (j >= 1 && reachable[i][j]) {
                    reachable[i - 1][j - 1] = true;
                }
            }
            
            // 如果 s[i] 是 ')' 或者是 '*' (可以变成 ')' )
            // 那么它是从状态 (i-1, j+1) 变成状态 (i, j) 的
            // 所以，如果状态 (i, j) 是通的，那么前一步状态 (i-1, j+1) 也是通的
            if (s[i] == ')' || s[i] == '*') {
                // j+1 <= i 其实是松散的界，严谨来说不超过 n 即可，这里写 <=i 也没问题
                if (j + 1 <= n && reachable[i][j]) { 
                    reachable[i - 1][j + 1] = true;
                }
            }
        }
    }
}

// ---------------------------------------------------------
// 模块2：构造字典序最小/最大的字符串 (getMaxMinString)
// f = 0: 求字典序最小 (优先填 '(' )
// f = 1: 求字典序最大 (优先填 ')' )
// ---------------------------------------------------------
string getMaxMinString(int f) {
    string str = s; // 复制一份原字符串用于修改
    int j = 0;      // 当前的积分（balance），初始为 0
    
    // 从第 1 个字符开始遍历到第 n 个
    for (int i = 1; i <= n; i++) {
        if (s[i] == '(') {
            j++; // 固定是 '('，没得选，积分+1
        } 
        else if (s[i] == ')') {
            j--; // 固定是 ')'，没得选，积分-1
        } 
        else { 
            // 当前是 '*'，我们需要做决定
            
            if (f == 0) { 
                // === 策略：求最小字典序，优先尝试填 '(' ===
                
                // 尝试填 '(': 现在的积分是 j，填了后变成 j+1
                // 我们查阅 reachable 表：如果走到状态 (i, j+1)，后面还能通向终点吗？
                if (j + 1 <= n && reachable[i][j + 1]) {
                    str[i] = '('; // 能通，那就填 '(' (因为它ASCII码小)
                    j++;          // 更新积分为 j+1
                } else {
                    str[i] = ')'; // 填 '(' 走不通，被迫填 ')'
                    j--;          // 更新积分为 j-1
                }
            } else { 
                // === 策略：求最大字典序，优先尝试填 ')' ===
                
                // 尝试填 ')': 现在的积分是 j，填了后变成 j-1
                // 我们查阅 reachable 表：如果走到状态 (i, j-1)，后面还能通向终点吗？
                // 注意：积分不能为负数，所以前提是 j >= 1
                if (j >= 1 && reachable[i][j - 1]) {
                    str[i] = ')'; // 能通，那就填 ')' (因为它ASCII码大)
                    j--;          // 更新积分为 j-1
                } else {
                    str[i] = '('; // 填 ')' 走不通，被迫填 '('
                    j++;          // 更新积分为 j+1
                }
            }
        }
    }
    return str.substr(1, n); // s是从下标1开始用的，所以截取 1 到 n
}

// ---------------------------------------------------------
// 模块3：计算总方案数 (getPlanNum)
// ---------------------------------------------------------
void getPlanNum() {
    // 遍历每一个位置 i
    for (int i = 1; i <= n; i++) {
        // 遍历每一种可能的积分 j
        for (int j = 0; j <= i; j++) {
            
            // 情况1: 当前字符是 '('
            // 只能由上一步积分 j-1 转移而来
            if (s[i] == '(') {
                if (j >= 1) dp[i][j] = (dp[i][j] + dp[i - 1][j - 1]) % mod;
            } 
            // 情况2: 当前字符是 ')'
            // 只能由上一步积分 j+1 转移而来
            else if (s[i] == ')') {
                if (j + 1 <= n) dp[i][j] = (dp[i][j] + dp[i - 1][j + 1]) % mod;
            } 
            // 情况3: 当前字符是 '*'
            // 既可以是 '(', 也可以是 ')'
            else {
                // 如果当做 '('：从 j-1 转移来
                if (j >= 1) dp[i][j] = (dp[i][j] + dp[i - 1][j - 1]) % mod;
                // 如果当做 ')'：从 j+1 转移来
                if (j + 1 <= n) dp[i][j] = (dp[i][j] + dp[i - 1][j + 1]) % mod;
            }
        }
    }
}

int main() {
    // 优化 I/O 速度
    ios::sync_with_stdio(false);
    cin.tie(0);

    cin >> s;
    // 为了方便处理，让下标从 1 开始
    s = " " + s; 
    n = s.length() - 1;

    // 初始化 DP 数组
    memset(dp, 0, sizeof(dp));
    
    // 初始状态：第 0 步，积分为 0，方案数为 1
    dp[0][0] = 1;

    // 1. 先计算方案总数
    getPlanNum();

    // 输出方案总数，dp[n][0] 即走到最后积分为0（合法）的方法数
    cout << dp[n][0] << endl;

    // 2. 如果存在方案（不为0），则构造并输出具体的字符串
    if (dp[n][0] != 0) {
        legalSeq(); // 先生成可行性地图
        cout << getMaxMinString(0) << endl; // 输出字典序最小
        cout << getMaxMinString(1) << endl; // 输出字典序最大
    }

    return 0;
}